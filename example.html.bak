<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lightweight Code Highlighter Example</title>
    <link rel="stylesheet" href="code_highlight.css">
    <style>
        body {
            background: #222;
            color: #eee;
            font-family: Arial, sans-serif;
            padding: 2rem;
        }
        h1, h2 {
            color: lightgray;
        }
        .section {
            margin-bottom: 2rem;
        }
    </style>
</head>
<body>
    <h1>Lightweight Code Highlighter Demo</h1>
    
    <div class="section">
        <h2>Examples from README.md</h2>
<pre class="code">
    {
        "Example": "JSON"
    }
</pre>

<pre class="code no-copy">
    {
        "Example": "JSON"
    }
</pre>

<span class="inline-code">{"Example": "JSON"}</span>
        </pre>
    </div>

    <div class="section">
        <h2>JavaScript Example</h2>
        <pre class="code">
function greet(name) {
    // Print a greeting
    if (name) {
        return "Hello, " + name + "!";
    } else {
        return "Hello, world!";
    }
}
        </pre>
    </div>
    <div class="section">
        <h2>Python Example</h2>
        <pre class="code">
def add(a, b):
    """Add two numbers"""
    return a + b  # returns the sum
        </pre>
    </div>
    <div class="section">
        <h2>Shell Command Example</h2>
        <pre class="code">
curl -X POST https://api.example.com/data --header "Authorization: Bearer TOKEN" --data '{"key":"value"}'
        </pre>
    </div>
    <div class="section">
        <h2>JSON Example</h2>
        <pre class="code">
{
    "name": "Lightweight Highlighter",
    "version": 1.0,
    "active": true
}
        </pre>
    </div>
    <div class="section">
        <h2>Inline Code Example</h2>
        <span class="inline-code">{ "inline": "JSON" }</span>
    </div>
    
    
    <div class="section">
        <h2>Longer Example</h2>
        <p>
            Here &lt; and &gt; have been escaped with 
            <span class="inline-code">&amp;lt;</span> and <span class="inline-code"> &amp;gt; </span> to prevent HTML parsing.
        </p>

        <span class="code">
// Calculating all primes from 2 to 2000000000
// optimize for time
//
// Uzi Cohen Â© 2019
//
 
// Added code for using all CPUs on machine, adapted from:
//
// Sample of launching C++11 threads that report what CPU they run on.
//
// Eli Bendersky [http://eli.thegreenplace.net]
// This code is in the public domain.
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;sched.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
 
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;climits&gt;
#include &lt;cfloat&gt;
#include &lt;cfenv&gt;
#include &lt;cmath&gt;
#include &lt;array&gt;
#include &lt;bitset&gt;
 
using namespace std;
 
#define MAX_NUM (2000000000LL)
#define PAGES (4)
#define MAX_PAGE (MAX_NUM/PAGES)
#define BITS_IN_ULL ((__CHAR_BIT__)*(__SIZEOF_LONG_LONG__))
#define MAX_NUM_SZ (MAX_NUM/BITS_IN_ULL)
#define NUM_PRIMES_TO_MASKTAB (12)
#define OFFSET_MASKTAB (64)
 
 
long int lastprime2Bil_idx;
 
#define BASE_PRIMES_SZ (5000)
unsigned long long int base_primes[BASE_PRIMES_SZ];
unsigned long long int base_mask_primes[NUM_PRIMES_TO_MASKTAB*OFFSET_MASKTAB];
 
void printOutAll(unsigned long long int *ints)
{
    stringstream fname;
    
    fname &lt;&lt; "primesAllBits.txt";
    
    ofstream fout(fname.str());
    
    for (unsigned long int idx=0; idx&lt;MAX_NUM_SZ; idx++)
        fout &lt;&lt; bitset&lt;64&gt;(ints[idx]) &lt;&lt; endl;
    
    fout.close();
}
 
void first_primes(void)
{
    vector&lt;unsigned long int&gt; vPrimes, vNums;
    unsigned long int max_prime = sqrt(MAX_NUM);
    
    vPrimes.clear();
    vPrimes.insert(vPrimes.end(),2);
    
    vNums.clear();
    for (uint32_t idx=0; idx&lt;=max_prime; idx++) {
        vNums.insert(vNums.end(),(idx%2)?1:0);
    }
    vNums[0] = 0;
    vNums[1] = 0;
    vNums[2] = 1;
    for (uint32_t idx=3; idx&lt;=max_prime; idx++) {
        if (vNums[idx]) {
            vPrimes.insert(vPrimes.end(),idx);
            for (uint32_t idx_idx=2*idx; idx_idx&lt;=max_prime; idx_idx+=idx) {
                vNums[idx_idx] = 0;
            }
        }
    }
    lastprime2Bil_idx = vPrimes.size() - 1;
    for (long int idx=0; idx &lt;= lastprime2Bil_idx; idx++) base_primes[idx] = vPrimes[idx];
    for (long int idx=lastprime2Bil_idx+1; idx &lt; BASE_PRIMES_SZ; idx++) base_primes[idx] = 0;
}
 
void sieve_optimized1(unsigned int startd, unsigned int sized)
{
    cout &lt;&lt; "Thread id: " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    
//    unsigned int startd = MAX_NUM_SZ/4;
//    unsigned int sized = MAX_NUM_SZ/4;
 
    unsigned long int prime_idx;
    unsigned long int *primes = new unsigned long int[BASE_PRIMES_SZ];
    unsigned long long int *bit = new unsigned long long int[BITS_IN_ULL];
    unsigned long long int *mask_primes = new unsigned long long int[NUM_PRIMES_TO_MASKTAB*OFFSET_MASKTAB];
    unsigned long long int *ints = new unsigned long long int[sized];
 
    for (int idx=0; idx&lt;BITS_IN_ULL; idx++) {
        bit[idx] = ~(1ULL&lt;&lt;idx);
    }
 
    // STEP 1: copying primes table to local copy
    std::copy(&base_primes[0],&base_primes[BASE_PRIMES_SZ],primes);
 
    std::fill(&ints[0],&ints[sized],0xAAAAAAAAAAAAAAAAULL);
    ints[0] &= ~0x3ULL;
    ints[0] |=  0x4ULL;
    
    // STEP 2: generating mask table for optimization of the sieve.
    std::copy(&base_mask_primes[0],&base_mask_primes[NUM_PRIMES_TO_MASKTAB*OFFSET_MASKTAB],mask_primes);
 
    long int idx;
 
    // sieve the primes
    for (prime_idx=1; prime_idx&lt;NUM_PRIMES_TO_MASKTAB; prime_idx++) {
        unsigned long int ints_idx, mask_idx;
        unsigned long int prime;
 
        // these are the most important optimizations
        // sieve for prime
        prime = primes[prime_idx];
        for (ints_idx=0, mask_idx=startd%prime; ints_idx&lt;sized; ints_idx++) {
            ints[ints_idx] &= mask_primes[prime_idx*OFFSET_MASKTAB+mask_idx];
            ++mask_idx %= prime;
        }
        ints[0] |= 1ULL&lt;&lt;prime; // set prime as a prime number
    }
     
    for (idx = NUM_PRIMES_TO_MASKTAB; idx &lt;= lastprime2Bil_idx; idx++) {
        unsigned long long int prime = primes[idx];
        unsigned long long int lastnum = sized*BITS_IN_ULL;
        for (unsigned long long int num=2*prime; num&lt;lastnum; num+=prime) {
            register int ints_idx = num&gt;&gt;6;
            register int bit_idx = num&63;
            ints[ints_idx] &= bit[bit_idx];
        }
    }
 
//    printOutAll(ints);
#ifdef DEBUG
    std::stringstream fname;
    fname &lt;&lt; "primesFr" &lt;&lt; startd*BITS_IN_ULL/1000000 &lt;&lt; "MTo" &lt;&lt; (startd+sized)*BITS_IN_ULL/1000000 &lt;&lt; "M.txt";
    std::ofstream fout(fname.str());
    unsigned long int sz = sized*BITS_IN_ULL;
    for (unsigned long int num=0; num&lt;sz; num++) {
        unsigned long int idx = num&gt;&gt;6;
        if ((~bit[num&63]) & ints[idx]) 
            fout &lt;&lt; num+startd*BITS_IN_ULL &lt;&lt; endl;
    }
#endif
    
    delete[] primes;
    delete[] bit;
    delete[] mask_primes;
    delete[] ints;
}
 
void sieve_optimized_other(unsigned int startd, unsigned int sized)
{
    cout &lt;&lt; "Thread id: " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;
    
//    unsigned int startd = MAX_NUM_SZ/4;
//    unsigned int sized = MAX_NUM_SZ/4;
 
    unsigned long int prime_idx;
    unsigned long int *primes = new unsigned long int[BASE_PRIMES_SZ];
    unsigned long long int *bit = new unsigned long long int[BITS_IN_ULL];
    unsigned long long int *mask_primes = new unsigned long long int[NUM_PRIMES_TO_MASKTAB*OFFSET_MASKTAB];
    unsigned long long int *ints = new unsigned long long int[sized];
 
    for (int idx=0; idx&lt;BITS_IN_ULL; idx++) {
        bit[idx] = ~(1ULL&lt;&lt;idx);
    }
 
    // STEP 1: copying primes table to local copy
    std::copy(&base_primes[0],&base_primes[BASE_PRIMES_SZ],primes);
 
    std::fill(&ints[0],&ints[sized],0xAAAAAAAAAAAAAAAAULL);
    
    // STEP 2: generating mask table for optimization of the sieve.
    std::copy(&base_mask_primes[0],&base_mask_primes[NUM_PRIMES_TO_MASKTAB*OFFSET_MASKTAB],mask_primes);
 
    long int idx;
 
    // sieve the primes
    for (prime_idx=1; prime_idx&lt;NUM_PRIMES_TO_MASKTAB; prime_idx++) {
        unsigned long int ints_idx, mask_idx;
        unsigned long int prime;
        
        
        // these are the most important optimizations
        // sieve for prime
        prime = primes[prime_idx];
        for (ints_idx=0, mask_idx=startd%prime; ints_idx&lt;sized; ints_idx++) {
            ints[ints_idx] &= mask_primes[prime_idx*OFFSET_MASKTAB+mask_idx];
            ++mask_idx %= prime;
        }
    }
     
    for (idx = NUM_PRIMES_TO_MASKTAB; idx &lt;= lastprime2Bil_idx; idx++) {
        unsigned long long int prime = primes[idx];
        unsigned long long int lastnum = (startd+sized)*BITS_IN_ULL;
        for (unsigned long long int num=((startd*BITS_IN_ULL+prime-1)/prime)*prime; num&lt;lastnum; num+=prime) {
            register int ints_idx = num&gt;&gt;6;
            register int bit_idx = num&63;
            ints[ints_idx-startd] &= bit[bit_idx];
        }
    }
    
#ifdef DEBUG
    std::stringstream fname;
    fname &lt;&lt; "primesFr" &lt;&lt; startd*BITS_IN_ULL/1000000 &lt;&lt; "MTo" &lt;&lt; (startd+sized)*BITS_IN_ULL/1000000 &lt;&lt; "M.txt";
    std::ofstream fout(fname.str());
    unsigned long int sz = sized*BITS_IN_ULL;
    for (unsigned long int num=0; num&lt;sz; num++) {
        unsigned long int idx = num&gt;&gt;6;
        if ((~bit[num&63]) & ints[idx]) 
            fout &lt;&lt; num+startd*BITS_IN_ULL &lt;&lt; endl;
    }
#endif
    
    delete[] primes;
    delete[] bit;
    delete[] mask_primes;
    delete[] ints;
}
 
void init(void)
{
    first_primes();
 
    // this is an abberation since 64 (number of bits in long long int) is divisible by
    // the prime 2
    std::fill(base_mask_primes,&base_mask_primes[NUM_PRIMES_TO_MASKTAB*OFFSET_MASKTAB],0xFFFFFFFFFFFFFFFFULL);
    
    for (unsigned long int prime_idx=0; prime_idx&lt;BITS_IN_ULL; prime_idx+=2)
      base_mask_primes[0] |= 1ULL&lt;&lt;prime_idx;
    base_mask_primes[0]=~base_mask_primes[0];
    
    for (unsigned long int prime_idx=1; prime_idx&lt;NUM_PRIMES_TO_MASKTAB; prime_idx++) {
        unsigned long int prime=base_primes[prime_idx];
        for (unsigned long int num=0; num &lt; prime*BITS_IN_ULL; num+=prime) {
            unsigned long int idx = num / BITS_IN_ULL;
            unsigned long int offset = num % BITS_IN_ULL;
            base_mask_primes[prime_idx*OFFSET_MASKTAB+idx] &= ~(1ULL&lt;&lt;offset);
        }
    }
}
 
//
int main(int argc, const char** argv) {
    unsigned num_cpus = std::thread::hardware_concurrency();
    
    num_cpus = 8;
    
    std::cout &lt;&lt; "Launching " &lt;&lt; num_cpus &lt;&lt; " threads\n";
 
    init();
    
    // A mutex ensures orderly access to std::cout from multiple threads.
    std::mutex iomutex;
    std::vector&lt;std::thread&gt; threads(num_cpus-1);
 
    if (num_cpus &gt; 1)
        for (unsigned thread_idx=0; thread_idx&lt;(num_cpus-1); thread_idx++)
            threads[thread_idx] = std::thread(sieve_optimized_other, (thread_idx+1)*MAX_NUM_SZ/num_cpus, MAX_NUM_SZ/num_cpus);
    sieve_optimized1(0, MAX_NUM_SZ/num_cpus);
 
    if (num_cpus &gt; 1) {
        for(auto& t : threads) {
            t.join();
        }
    }
    return 0;
}

        </span>
    </div>
    <script src="code_highlight.js"></script>
</body>
</html>